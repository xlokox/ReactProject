## הסבר מלא – מא׳ ועד ת׳ – איך בניתי והפעלתי את כל המערכת (בגוף ראשון)

להלן מסמך הסבר מפורט בעברית, בגוף ראשון, המתאר את תהליך העבודה המלא שביצעתי בפרויקט ReactProject. אני מסביר על כל השכבות: מסד הנתונים (MongoDB/Mongoose), השרת (Node/Express), הסנכרון (API, אבטחה, CORS), הפרונט־אנד (React + Redux), האפליקציה הסלולרית (React Native + Expo), ומנגנון ה-Hero Section Banners (קמפיינים) שהוספתי, כולל כל התיקונים שביצעתי כדי לוודא שהכל עובד בקונסיסטנטיות ובזמן אמת.

---

### 1) ארכיטקטורה כללית – איך בניתי את המבנה הלוגי

1. בחרתי בארכיטקטורת MERN:
   - MongoDB כמסד נתונים דוקומנטרי.
   - Mongoose למידול סכמות וולידציה בצד השרת.
   - Express כשרת API מודולרי.
   - React לפרונט־אנד ו-React Native לאפליקציה.
2. סידרתי את התיקיות כך שתהיה הפרדה ברורה בין backend, frontend, dashboard (למוכרים/אדמין) ו-Ecommerce_App (האפליקציה הסלולרית ב-Expo).
3. שמרתי על נקודת כניסה אחת לשרת: Ecommerce/backend/server.js. שם אני מגדיר CORS, Cookies, אבטחה, ראוטרים של הדומיין (מוצרים, קטגוריות, הזמנות, צ׳אט, תשלומים, קמפיינים), ובריאות השרת.
4. הוספתי שכבת Middleware לאבטחה, אימות JWT, ולוגינג, כדי שכל בקשה עוברת מסלול עקבי לפני הגעה לפעולה העסקית (Controller).
5. הגדרתי חיבור ל-Socket.io לשיחות בזמן אמת, אך הקפדתי שהקמפיינים יישארו REST סטנדרטי, כדי לאפשר קאשינג, DevTools וכלים פשוטים לבדיקה.

---

### 2) מסד הנתונים (MongoDB) והסכמות (Mongoose)

הקפדתי להגדיר סכמות ברורות עם שדות מתוייגים, טיפוסים, ברירות מחדל וולידציות. לדוגמה – סכמה של קמפיין (Hero Banner):

- קובץ: Ecommerce/backend/models/campaignModel.js
- שדות מרכזיים:
  - title: כותרת גדולה לבאנר (חובה, trim)
  - subtitle: כותרת משנה (ברירת מחדל ריק)
  - image: קישור לתמונה (חובה)
  - textColor: צבע הטקסט, ברירת מחדל לבן (#ffffff)
  - titleSize: גודל פונט כותרת (ברירת מחדל 48, טווח 8–200)
  - ctaText: טקסט כפתור/קריאה לפעולה
  - ctaLink: לאן לנווט בלחיצה (למשל /products או קישור לקטגוריה)
  - order: סדר תצוגה (מספר, מאפשר גרירה/מיון בעתיד)
  - active: האם להציג כרגע (boolean)
  - startAt / endAt: חלון זמן לתצוגה (null = ללא הגבלה)
  - createdBy: מזהה יוצר (אדמין/סלר)
  - timestamps: ניהול אוטומטי של createdAt/updatedAt

החלטות תכנוניות שעשיתי:
- הגדרתי את order כברירת מחדל 0, כך שאפשר למיין, אבל גם אם לא הגדירו – יש סדר עקבי (לפי createdAt יורד בעת הצורך).
- השארתי startAt/endAt עם null כערך חוקי, כך שאפשר להפעיל קמפיין "ללא תאריך תפוגה" – זה שימושי לדפי מבצעים קבועים.
- שמרתי textColor ו-titleSize ברמת ה-DB כדי לתת שליטה חזותית מלאה דרך הדאשבורד, בלי לבנות גרסאות ייעודיות בקוד הפרונט.

---

### 3) שכבת השרת (Express) – בניית ה-API והבקרה

נקודת הכניסה: Ecommerce/backend/server.js

מה עשיתי כאן:
1. הפעלתי dotenv לטעינת משתני סביבה.
2. הגדרתי bodyParser.json ו-URL-encoded לקבלת טפסים ו-JSON.
3. הפעלתי cookieParser כדי לקבל גישה לקוקיות (נדרש ל-JWT דרך Cookies כשצריך).
4. הפעלתי securityMiddleware להגנות בסיסיות.
5. הגדרתי CORS עם origin מרובים: localhost:3000 (ו-3001/3002), וגם תבניות IP ל-Expo (192.168.x.x:19006 וכו׳) – כדי שהאפליקציה בטלפון תוכל לפנות לשרת בלי חסימות.
6. הוספתי exposedHeaders/allowedHeaders כדי לאפשר X-CSRF-Token, Authorization וכד׳.
7. ייבאתי והפעלתי את כל הראוטרים תחת prefix /api. חשוב: סדר הרישום קובע! על זה ארחיב בסעיף הבאנרים.
8. הפעלתי Socket.io עם Cors תואם mobile, כולל fallback ל-polling.
9. יצרתי /api/health ו-/api/test כדי לבדוק זמינות והרשאות בסיסיות.
10. הפעלתי את השרת על פורט 5001 (ברירת מחדל), עם dbConnect() למסד הנתונים.

---

### 4) אימות ואבטחה – JWT, Cookies, ותפקידי משתמש

- קובץ: Ecommerce/backend/middlewares/authMiddleware.js
- לוגיקה:
  - אני מחפש טוקן קודם כל ב-Cookie בשם accessToken; אם אין – מחפש ב-Authorization Header (תומך בשני הפורמטים: "Bearer <token>" או רק הטוקן עצמו).
  - אני מאמת את הטוקן עם JWT_SECRET, ושומר ב-request את id וה-role של המשתמש.
  - במקרה של TokenExpiredError או JsonWebTokenError – מחזיר 401 עם הודעה ברורה.

- בדאשבורד/מוכרים/אדמין:
  - הוספתי helper requireRole(['admin','seller']) כדי להגביל פעולות יצירה/עדכון/מחיקה של קמפיינים רק לבעלי תפקידים נכונים.

- בצד ה-frontend:
  - ב-Ecommerce/frontend/src/api/api.js יצרתי axios instance עם baseURL = REACT_APP_API_URL או http://localhost:5001/api.
  - הפעלתי withCredentials: true כדי להעביר קוקיות במידת הצורך.
  - הוספתי interceptor שמוסיף X-CSRF-Token מהקוקיות אם קיים, וטוקן לקוח (customerToken) מה-localStorage ל-Authorization.
  - הוספתי ניסיון רענון טוקן על 401 באמצעות /auth/refresh-token, ואם נכשל – מנקה טוקן ומפנה ל-/login.

---

### 5) סנכרון הבאנרים (Campaigns) בין השרת לפרונט ולאפליקציה – מא׳ ועד ת׳

זה החלק הקריטי שהשקעתי בו כדי לוודא שליטה מלאה מהדאשבורד וסנכרון מלא:

1. מודל הקמפיין: כפי שפירטתי בסעיף הסכמה.
2. Controller: Ecommerce/backend/controllers/dasboard/campaignController.js
   - create: מקבל גם URL של תמונה וגם קובץ תמונה (formidable). אם קיבלתי URL – אני משתמש בו; אם קיבלתי קובץ – אני מעלה ל-Cloudinary ושומר את ה-URL. אם אין תמונה – מחזיר 400.
   - update: מאפשר לעדכן מבלי להעלות תמונה חדשה; אם field image הוא URL, אני שומר אותו; ואם קובץ חדש – מעלה ומעדכן. ממיר titleSize/order ל-Number, active ל-Boolean, תאריכים ל-Date.
   - remove: מוחק לפי id.
   - list: מחזיר את כל הקמפיינים (למסך הניהול), ממוינים לפי order ואז createdAt.
   - get: קמפיין בודד לפי id.
   - publicList: זו הנקודה החשובה לפרונט/אפליקציה – מחזירה רק קמפיינים פעילים (active: true) שבתוך חלון הזמן (או ללא חלון), ממוינים לפי order ואז createdAt. זה מה שה-Home והאפליקציה צורכים.

3. Routes: Ecommerce/backend/routes/dashboard/campaignRoutes.js
   - כאן ביצעתי את התיקון הקריטי: סדר הנתיבים! קודם כל אני רושם את /campaigns/public, ורק אחריו את /campaigns/:id. אם הייתי שם קודם את /:id – הבקשות ל/public היו נתפסות בטעות כ-id="public" (היה מחזיר 401 כי יש אימות על :id), וזה בדיוק מה שתפסתי בלוגים וסידרתי. ככה פתרתי את שגיאת 401 שראינו ב-console.
   - כל ראוטי ה-Admin (create/update/delete/list/get) מוגנים ב-authMiddleware + requireRole(['admin','seller']).
   - ראוט publicList פתוח לקריאה ללא אימות.

4. פרונט־אנד (Web): Ecommerce/frontend/src/components/Banner.jsx
   - יצרתי useEffect שמבצע fetch ל-`${REACT_APP_API_URL || 'http://localhost:5001/api'}/campaigns/public`.
   - אם קיבלתי מערך קמפיינים – אני ממפה אותו לשקף עבור הקרוסלה: { id, image, label, link, titleSize, textColor }.
   - אם קיבלתי ריק/שגיאה – אני מציב placeholder נייטרלי (dummyimage.com) כדי שלא יהיו "דמו" ישנים שמבלבלים את הלקוח. רציתי Placeholder שאינו חוסם ולא מצריך DNS מיוחד (בניגוד ל-via.placeholder.com שראיתי שעלול להכשל ברשתות מסוימות – לכן עברתי ל-dummyimage.com).
   - בניתי את הקרוסלה עם react-multi-carousel ועטפתי כל שקף ב-Link בהתאם ל-ctaLink (למשל /products או מסנן קטגוריה).

5. אפליקציה סלולרית (React Native): Ecommerce_App/App.js
   - הגדרתי מצב banners עם ברירת מחדל PLACEHOLDER_BANNERS (סט אחיד ונייטרלי).
   - הפעלתי useEffect שמושך מ-`${API_BASE_URL}/campaigns/public` וממפה ל- {_id, banner, label, action}. את action אני בונה מפונקציה parseAction(link) שמזהה אם זה category/product/search ויודעת לנווט בהתאם באפליקציה.
   - אם אין תוצאות – משאיר את PLACEHOLDER_BANNERS. זה מבטיח UI אחיד תמיד.
   - ניהול קרוסלה: יש לי FlatList אופקי עם ref, מדדי אינדקס נוכחי, וכפתורי Next/Prev. יש טיימר שמבצע auto-advance כל כמה שניות, תוך כיבוד אינטראקציה ידנית (isUserInteracting) כדי שלא "אלחם" עם המשתמש.
   - אינדיקטור נקודות (dots) תואם בדיוק לאתר.

6. מה פתרתי בפועל כדי "לתת לי שליטה מלאה בקמפיינים":
   - הבטחתי ש-publicList הוא נתיב פתוח וללא אימות, ושנרשם לפני /:id כדי למנוע 401 בטעות.
   - הוצאתי את הדמו הקשיח הישן משני הצדדים (Web + Mobile) והחלפתי ב-placeholder נייטרלי שנעלם ברגע שמוגדר קמפיין אמיתי.
   - ווידאתי שבדאשבורד אפשר:
     - ליצור קמפיין עם תמונה כ-URL או קובץ.
     - לעדכן קמפיין בלי להעלות תמונה חדשה (שומר את הקיים).
     - למחוק קמפיין.
     - לראות רשימה מלאה מסודרת.
   - בצריכה ציבורית – אני מחזיר רק פעילים ובתוקף, כך שאין "דליפות" של טיוטות.

---

### 6) Redux – איך ארגנתי את ה-Store, Reducers ו-Thunks

באתר (frontend) יש Store מסודר עם reducers שונים. ספציפית, יש לנו homeReducer שבו קיים thunk get_banners שנועד היסטורית למשוך באנרים מ-"/banners". מאחר ומנגנון הקמפיינים (campaigns) הוא המודרני והמדויק, את ה-Hero אני טוען ישירות ב-Banner.jsx מ-"/campaigns/public" (בלי לעבור ב-Redux). עשיתי זאת בכוונה: ה-Hero הוא אובייקט פשוט יחסית, ואני רוצה להימנע מתלויות מיותרות ברגעי הטעינה הראשוניים.

לצד זאת, השארתי את get_banners ב-Redux לשימוש עתידי או למסכים אחרים שעשויים להזדקק לנתונים דומים. אם נחליט לאחד – אפשר להעביר את הקריאה ל-Redux בצורה קלה, ולחבר את Banner.jsx ל-selector. ההחלטה נשארה מודולרית כדי לשמור על פשטות כעת וגמישות לעתיד.

ב-Ecommerce/frontend/src/api/api.js הגדרתי axios עם interceptors כדי שלכל thunk יהיו כבר כותרות (Headers) נכונות, כולל Authorization ו-CSRF במידת הצורך.

---

### 7) CORS, Expo והפניות Base URL – איך דאגתי שהמובייל והווב מדברים עם אותו שרת

- בצד השרת (server.js) הפעלתי cors עם origins מותאמים לפיתוח – localhost:3000/3001/3002, וכן Regexים שמאפשרים IP מקומי ל-Expo על פורט 19006. כך ה-Expo Go בטלפון יכול לבצע קריאות ל-API בלי חסימות דפדפן.
- בצד הווב, אני משתמש ב-REACT_APP_API_URL אם קיים (למשל http://localhost:5001/api). אם לא קיים – אני נופל לברירת המחדל.
- בצד המובייל, API_BASE_URL נקבע בהתאם להגדרות האפליקציה (ב-App.js), ובפרקטיקה פונה לאותו שרת. בעת פיתוח, חשוב להפעיל את Expo במצב Tunnel או לוודא שהטלפון והשרת על אותה רשת וללא חסימות.

בדיקות שעשיתי:
- פתיחת /api/campaigns/public ב-DevTools של הדפדפן – ווידאתי שמוחזר JSON עם campaigns.
- בדקתי רינדור מיידי של הבאנר לאחר יצירה/מחיקה בדאשבורד.
- במובייל – Reload ל-Expo ולאחר מכן ווידוא שהשקופיות תואמות לאתר.

---

### 8) הטמעת העלאת תמונות – URL או קובץ – ולמה בחרתי Cloudinary

- בחרתי לאפשר גם URL וגם קובץ, כדי לא להגביל את מנהלי התוכן: לפעמים יש כבר נכס בענן, ולפעמים רוצים להעלות קובץ נקודתי.
- השתמשתי ב-cloudinary.v2.uploader.upload בקונטרולר כדי להעלות קובץ ולשמור כתובת URL יציבה ומהירה.
- שמרתי את ההגדרות ב-env והפעלתי secure: true.

---

### 9) טיפול בתקלות שנתקלתי בהן – ומה עשיתי

1. 401 על /api/campaigns/public:
   - בעיית סדר ראוטים – /campaigns/:id לפני /campaigns/public גרם לכך ש"public" זוהה בתור id ונדרש JWT. פתרתי על ידי העברת הנתיב הציבורי למעלה – לפני :id. מרגע זה, הבקשה הציבורית עוברת ללא אימות.

2. Placeholder שלא נטען:
   - ראיתי ב-console כשלי DNS ל-via.placeholder.com. החלפתי ל-dummyimage.com שמחזיר תמונה פשוטה ויציבה יותר בסביבות פיתוח שונות.

3. קונפיגורציית CORS ל-Expo:
   - הוספתי Regexים לכתובות IP נפוצות של רשתות מקומיות, כדי לאפשר גישה מהטלפון.

4. הפרדת אחריות:
   - העברתי את טענת הקמפיינים ב-Hero ל-fetch ישיר בקומפוננטה, כדי לצמצם רגישות ל-redux/thunk שעלול להתנגש בזמני טעינה, ולשמור על UX חלק.

---

### 10) זרימת נתונים מקצה לקצה (E2E) – איך זה נראה בפועל

1. אני נכנס לדאשבורד ומייצר קמפיין חדש – עם תמונה (URL/קובץ), כותרת, צבע טקסט, קישור, Active=true, ואולי גם חלון תאריכים.
2. צד השרת יוצר את הדוקומנט ב-MongoDB ומחזיר 201.
3. בדף הבית של האתר, Banner.jsx שולח GET ל-/api/campaigns/public, מקבל מערך מסונן של קמפיינים פעילים, ממפה, ומציג בקרוסלה. אם המערך ריק – מציג Placeholder.
4. באפליקציה, App.js מבצע אותו GET ומציג בקרוסלת המובייל.
5. בלחיצה על שקף:
   - באתר – Link מעביר לעמוד הרלוונטי.
   - באפליקציה – parseAction(link) מנתחת את ה-CTA, ובונה ניווט בהתאם (קטגוריה/מוצר/חיפוש/עמוד כללי).

---

### 11) קווי הנחיה לתחזוקה והרחבה – מה הייתי עושה הלאה

- הוספת Drag & Drop לניהול order בדאשבורד.
- הוספת Preview (כפתור "תצוגה מקדימה") שיפתח את דף הבית עם פרמטר שמדגיש שקף ספציפי.
- העברת קריאת הקמפיינים ל-redux אם נרצה קאשינג גלובלי/SSR בעתיד.
- הוספת בדיקות יחידה ל-controller (publicList, create, update) – לוודא שהתאריכים והסינון עובדים.
- הוספת rate limiting לראוטים ציבוריים.

---

### 12) סיכום – למה זה נותן לי שליטה מלאה

- אני שולט בתוכן דרך הדאשבורד: יצירה, עדכון (כולל בלי להעלות תמונה חדשה), מחיקה, ומיון.
- הפרונט והאפליקציה מציגים באופן אחיד את מה שמוחזר מ-publicList בלבד – כלומר רק קמפיינים פעילים ובתוקף.
- אין יותר דמו קשיח שמבלבל – יש Placeholder אחיד שנעלם ברגע שמוגדר קמפיין אמיתי.
- תקלות נפוצות (CORS, 401, DNS ל-placeholder) טופלו מראש.

---

להמשך הרחבה: אשמח להגדיל את המסמך עם פירוט עמוק יותר על כל רדיוסר/סאגה/Thunk, סכמות נוספות (מוצרים, קטגוריות, הזמנות), זרימות צ׳אט ותשלומים, ותרחישי שגיאה. אם תרצה – אוסיף גם דוגמאות JSON מלאות, ותרחישי בדיקות אוטומטיות.



### 13) פירוט Redux בצד הווב – מבנה, סטייט, פעולות, ושליפות

אני בניתי את Redux כך שיהיה ניתן להרחיב אותו בקלות ולחבר מסכים חדשים בלי לשבור את הזרימות הקיימות.

- מבנה כללי:
  - store/ – מאגד את ה-slices/reducers ומפעיל middleware ברירת מחדל של Redux Toolkit.
  - api.js – אינסטנס יחיד של axios עם interceptors (כאמור) כך שכל thunk נהנה מקונפיגורציה אחידה.
- עקרונות:
  - שמרתי את ה-state שטוח (flat) ככל האפשר, עם מזהים (id) כאשר צריך, כדי להקל על עדכונים אימיוטבילים.
  - כל thunk אחראי להחזיר מבנה נתונים "מוכן להצבה" ב-state, כדי להפחית לוגיקה בתוך reducers.
- דוגמאות ל-slices נפוצים (רמה לוגית):
  - homeReducer: אחראי לקטגוריות, מוצרים מובילים, וסיגנלים ראשיים למסך הבית.
  - productReducer: טעינת מוצר/ים, חיפוש, סינון, עמודי פרטים.
  - cardReducer: ניהול עגלת קניות – פריטים, כמויות, סכום ביניים, ושליחת הקריאה לשרת.
  - authReducer: סטטוס התחברות לקוח (לא אדמין), טעינת פרופיל, חידוש טוקן.
  - orderReducer: יצירת הזמנה, היסטוריית הזמנות, פרטי הזמנה.
  - chatReducer: סטטוס חיבור לצ׳אט, רשימות שיחות, הודעות, חיווי הקלדה.
- עבודה אימיוטבילית:
  - הקפדתי להשתמש ב-Immer שמגיעה מובנית עם Redux Toolkit ולכן אפשר "לכתוב אימפרטיבי" (state.x = y) בלי לשבור אימיוטביליות.
- Selectors:
  - לכל slice יש Selectors פשוטים שמייצרים תתי-תצוגה למסכים (לדוגמה: getProductsByCategory). במידת הצורך ניתן להוסיף reselect.
- ניהול שגיאות וטעינה:
  - בכל thunk אני שומר שלושה שדות סטנדרטיים ב-slice: loading, error, successMessage (כאשר רלוונטי), כך שכל מסך יכול להציג Loader/Alert בצורה אחידה.

### 14) זרימות אימות לקוח מקצה לקצה (Login/Register/Refresh)

אני הקפדתי על אבטחה ותאימות UX:

- הרשמה (Register):
  - הלקוח שולח פרטי הרשמה ל-/api/customer/register (לדוגמה). בצד השרת אני מוודא תקינות, יוצר משתמש, ושולח חיווי הצלחה/כשל.
- התחברות (Login):
  - המשתמש שולח אימייל/סיסמה; בצד השרת אני בודק, יוצר JWT ומחזיר אותו או ב-Set-Cookie (httpOnly כאשר רלוונטי) או בגוף תגובה (ללקוחות – לעיתים נשמר ב-localStorage כ-customerToken). הקפדה שלא לחשוף JWT של אדמין בפרונט.
- Interceptors:
  - כל בקשה יוצאת עם Authorization: Bearer <customerToken> אם קיים; CSRF token נוסף מה-cookie כאשר יש מנגנון כזה פעיל.
- רענון טוקן (Refresh):
  - אם מתקבלת שגיאת 401 על בקשה רגילה, אני מנסה לבצע POST ל-/auth/refresh-token; במקרה של הצלחה – שולח שוב את הבקשה המקורית; במקרה של כשל – מנקה את ה-token ומנתב ל-/login.
- הגנת ראוטים בצד הווב:
  - קומפוננטות הגנה (ProtectUser) עוטפות אזורי לקוח ומוודאות שיש סטטוס התחברות תקין; אחרת – הפנייה ל-/login.
- ניווט ותפריטים מותנים:
  - תפריט ניווט ותתי רכיבים מוצגים רק כאשר יש סטטוס התחברות תקין – כך לא נחשפת פונקציונליות לקוח בלי להתחבר.

### 15) עגלת הקניות – מודל, סנכרון, ותיקון באג המחיקה

הקפדתי לבנות עגלת קניות יציבה שתהיה מסונכרנת בין הלקוח לשרת:

- סטייט עיקרי ב-cardReducer:
  - items: מערך פריטים { productId, title, price, qty, image, variant ... }
  - subtotal: סכום ביניים, מחושב מיידית בכל שינוי.
  - loading/error: לניהול UI.
- פעולות עיקריות:
  - addToCart(product, qty)
  - updateQty(productId, qty)
  - removeFromCart(productId)
  - clearCart()
  - syncCartFromServer()
- סנכרון לשרת:
  - על פעולות מרכזיות אני שולח בקשה לשרת לשימור העגלה (אם המשתמש מחובר). אם המשתמש לא מחובר – אני שומר מקומית ומציג CTA להתחברות לשימור.
- הבאג שתפסתי ("נמחק בלוגים אבל לא יורד מה-UI"):
  - מקור שכיח: עדכון אימיוטבילי לא נכון ב-reducer או תלות בקי של רכיב React שלא התעדכן.
  - הפתרון שהחלתּי: ודאתי שה-reducer של removeFromCart מבצע state.items = state.items.filter(i => i.productId !== productId) ולא mutate לא עקבי; ווידאתי שהרכיב CardPage מקבל key נכון, ושה-selectors אינם קאש ״ישָן".
  - בנוסף, הוספתי dispatch של פעולה מסכמת שמציינת הצלחה מהשרת – כדי לסנכרן סטטוס UI עם תשובת ה-API.

### 16) קטגוריות ומוצרים – CRUD, סנכרון והצגה

- קטגוריות:
  - טעינת רשימת קטגוריות למסכי ניווט, פילטרים, וקישורי CTA (כולל התאמת שם קטגוריה ל-id עבור קישורים בבאנרים).
- מוצרים:
  - תמיכה בעימוד (pagination) ובטעינה מדורגת (infinite scroll) היכן שצריך.
  - תמיכה בסינון לפי קטגוריה/טווח מחירים/דירוג/חידושים.
  - דף פרטי מוצר עם גלריה, תיאור, ביקורות ודירוגים.
- סנכרון בין הווב למובייל:
  - שמרתי על מבני נתונים אחידים ככל האפשר, כך שהאפליקציה הסלולרית יכולה להשתמש באותם שדות להצגה מהירה.
  - כאשר יש הבדלי UX (למשל גודל כותרת/תמונות) – הטעמתי ברמת הפרזנטציה בלבד, לא ברמת המודל.


### 17) Hero Section Banners – ארכיטקטורה מפורטת, מקרי קצה ותזמון

כאן אני נכנס ממש לעומק המימוש של קמפייני ה-Hero, כדי להראות איך נתתי לעצמי שליטה מלאה מהדאשבורד ועד למסכי הלקוח והמובייל.

- מודל נתונים (סיכום):
  - title (חובה), subtitle (אופציונלי), image (חובה), textColor, titleSize, ctaText, ctaLink, order, active, startAt, endAt, createdBy.
- אינדקסים (המלצה):
  - על order, active, startAt, endAt – כדי לייעל את השאילתות הציבוריות. אפשר להוסיף בהמשך index משולב: { active: 1, startAt: 1, endAt: 1, order: 1 }.
- אלגוריתם סינון publicList:
  1. now = new Date().
  2. חיפוש: active: true.
  3. תנאי זמן:
     - startAt: null או startAt <= now.
     - endAt: null או endAt >= now.
  4. מיון: order עולה, ואז createdAt יורד (כך שקמפיין חדש עם אותו order יופיע ראשון).
- מקרי קצה שטיפלתי בהם:
  - startAt/endAt = null: הקמפיין תמיד זמין כל עוד active=true.
  - startAt מוגדר בעתיד: לא יוצג עד לתאריך המוגדר.
  - endAt מוגדר בעבר: לא יוצג כבר.
  - titleSize חריג (קטן מדי/גדול מדי): אני מגביל 8–200 בסכמה כדי לא לשבור UI.
  - textColor לא קריא על רקע התמונה: זו החלטה של מנהל התוכן; אפשר להוסיף בדיקות ניגודיות בהמשך.
  - ctaLink לא תקין: בצד הווב/מובייל אני מגדיר נפילות חן ל-/products או פעולה ניטרלית.
- תבניות קישורים (ctaLink) – החלטה שאני יישמתי:
  - /products – הצגת כל המוצרים.
  - /products?category=<name-or-id> – סינון לפי קטגוריה (במובייל אני מנתח את הלינק וממפה לניווט פנימי).
  - /product/details/<slug> – ניתוב ישיר למוצר ספציפי.
  - /search?query=... – לעמוד חיפוש.
  - לינק חיצוני (http/https) – פתיחה ב-tab חדש באתר, או במובייל abrir באמצעות Linking.
- מיפוי בשכבת הפרזנטציה:
  - Web: Link ל-route הפנימי, עם alt/titles נגישים.
  - Mobile: parseAction(link) שמחזירה { type, params } ומשתמשת ב-navigation.navigate.
- טעינת נתונים ולוגיקת fallback:
  - Web: useEffect ב-Banner.jsx – fetch ל-/campaigns/public, מיפוי לשקפים, ואם אין – dummyimage placeholder.
  - Mobile: useEffect ב-App.js – fetch ל-/campaigns/public, מיפוי ל-state banners, ואם אין – PLACEHOLDER_BANNERS (סט קבוע).
- ניהול זמן ואוטומציה בקרוסלה (מובייל):
  - setInterval שמקדם את האינדקס הנוכחי כל N שניות.
  - אם המשתמש גולל/לחץ חצים – אני משבית זמנית את האוטומציה כדי לא להילחם איתו, ואז מחזיר אותה לאחר Timeout קצר.
  - דאגתי שהאינדקס תמיד יישאר בטווח באמצעות מודולו על אורך המערך.
- נגישות (Accessibility):
  - תמונות כוללות alt הטקסט שווה ל-label.
  - צבעי טקסט ניתנים להגדרה; ניתן להוסיף בעתיד חיווי ARIA לשינויים בקרוסלה.

### 18) Routing בצד השרת – סדר, אבטחה וקריאות לדוגמה

אני שם דגש חזק על סדר הרשמה של הראוטים באקספרס – כי הוא קריטי לתוצאה נכונה:

- קובץ: Ecommerce/backend/routes/dashboard/campaignRoutes.js
- הסדר הנכון:
  1. GET /campaigns/public – נתיב ציבורי (ללא אימות) – לפני כל נתיב פרמטרי.
  2. נתיבי אדמין/סלר מוגנים: POST /campaigns, PUT /campaigns/:id, DELETE /campaigns/:id, GET /campaigns, GET /campaigns/:id.
- למה זה חשוב:
  - אם הייתי רושם קודם GET /campaigns/:id – אז הפתיח "public" היה נלכד כ-id, ומכיוון שמדובר בנתיב מוגן – השרת היה מחזיר 401 (בדיוק הבאג שתפסתי ותיקנתי).
- curl לדוגמה (פיתוח):
  - שליפה ציבורית:
    - curl http://localhost:5001/api/campaigns/public
  - יצירה (עם URL כתמונה):
    - curl -H "Authorization: Bearer <admin-or-seller-token>" -F "title=Black Friday" -F "image=https://cdn.../hero.jpg" http://localhost:5001/api/campaigns
  - יצירה (עם העלאת קובץ):
    - curl -H "Authorization: Bearer <token>" -F "title=New Year" -F "image=@./local-hero.jpg" http://localhost:5001/api/campaigns
  - עדכון ללא העלאת תמונה חדשה:
    - curl -X PUT -H "Authorization: Bearer <token>" -F "title=New Title" http://localhost:5001/api/campaigns/<id>
  - מחיקה:
    - curl -X DELETE -H "Authorization: Bearer <token>" http://localhost:5001/api/campaigns/<id>

### 19) Banner.jsx – פירוט מלא בצד הווב

אני מפרט את השיקולים המרכזיים בבניית הקומפוננטה:

- State מקומי: slides (מערך שקפים לאחר מיפוי מהשרת).
- useEffect:
  - מושך publicList, ממפה, או מציב fallback (dummyimage) במקרה של שגיאה/ריק.
- Carousel (react-multi-carousel):
  - responsive breakpoints: mobile/tablet/desktop/superLargeDesktop – תמיד 1 פריט, רק הגדלים משתנים.
  - autoPlay, infinite, arrows, showDots – מותאמים לחוויית אתר.
- מבנה שקף:
  - <img> מלאה, object-cover, עם class גמיש לכל גדלי המסך.
  - שכבת overlay מרכזית עם טקסט label, עם textShadow לשיפור קריאות על רקעים בהירים.
- ניווט:
  - עטפתי כל שקף ב-Link לנתיב מ-ctaLink; אם link ריק – אני מפנה ל-/products.
- ביצועים:
  - אפשר להוסיף lazy-loading לimg (loading="lazy") בדפדפנים תומכים.
  - אפשר לצמצם משקלי תמונות ב-Cloudinary עם פרמטרים (f_auto,q_auto).
- נגישות:
  - alt={slide.label}.
  - כפתורי חצים ודוטים אמורים להיות focusable; ניתן להוסיף aria-labels להנחיה קולית.

### 20) App.js במובייל – ניווט, parsing, ושליטה מלאה על הקרוסלה

- מצב התחלתי: banners = PLACEHOLDER_BANNERS כדי למנוע הבהובים בזמן שהרשת נטענת.
- useEffect לטעינה:
  - fetch ל-/campaigns/public.
  - מיפוי לשדות {_id, banner, label, action}.
  - setBanners(mapped.length ? mapped : PLACEHOLDER_BANNERS).
- parseAction(link):
  - מזהה:
    - סוג "category" – שולח לקטגוריה הרלוונטית (מצאתי id לפי שם במפה קיימת, או שולח למסך products עם סינון).
    - סוג "product" – מעביר לדף פרטי מוצר לפי slug/id.
    - סוג "search" – לניווט למסך חיפוש עם שאילתא.
    - ברירת מחדל – מסך המוצרים הכללי.
- קרוסלה:
  - FlatList אופקי עם pagingEnabled.
  - dot indicators תואמים לאתר.
  - חיצים (TouchableOpacity) עם onPress שמחשב prevIndex/nextIndex במודולו של האורך.
  - טיימר auto-advance עם clearInterval ב-unmount; דאגתי למנוע קידום בזמן אינטראקציה ידנית ולחדש אחריה.
- יציבות:
  - שמרתי הפניות עם useRef כדי למנוע setState לאחר unmount.
  - הקפדתי לעטוף קריאות בניסיונות try/catch ולהשאיר placeholder במקרה של כשל.

### 21) עבודת Redux מעמיקה – Action Lifecycles, Selectors ונירמול

- Redux Toolkit createAsyncThunk מספק שלושה מצבים: pending/fulfilled/rejected. אני משתמש בהם לעדכן loading/error בכל slice.
- Normalization:
  - כאשר אני טוען רשימות גדולות (מוצרים/קטגוריות), אני שוקל לשמור מפות לפי id כדי להאיץ שליפות ולאפשר עדכון אובייקטים בודדים בלי לעבור על מערך ארוך.
- Selectors מתקדמים:
  - reselect מאפשר ליצור memoized selectors שחוסכים רינדורים מיותרים.
- דפוסי שגיאות:
  - בכל thunk אני מחזיר rejectWithValue עם אובייקט סטנדרטי { message, code } כדי שה-UI יציג הודעה עקבית.
- בדיקות:
  - ניתן לבדוק reducers כטוהרים (pure) ולוודא שהמעבר בין מצבים (add/remove) נכון.

### 22) ביצועים במסד ובשרת – אינדקסים, Projection ותיחום שדות

- במסד:
  - הוספת אינדקסים על שדות פילטר נפוצים (active, startAt, endAt, order) תוריד זמני תגובה.
- בשאילתות:
  - שימוש ב-select (projection) כדי להחזיר רק את שדות התצוגה הנחוצים ל-publicList (למשל: title, image, ctaLink, textColor, titleSize, order) – אפשרות להמשך.
- עמודי מוצרים:
  - limit + skip לעימוד; קביעת סדר לפי פופולריות/דירוג/תאריך.
- קאשינג:
  - ניתן להוסיף שכבת קאשינג במטמון זיכרון או Redis לקמפיינים (TTL קצר), אם יעלה צורך ביצועים.

### 23) אבטחה – שכבות הגנה והפרדה בין תפקידי משתמש

- JWT:
  - בצד השרת, authMiddleware מאמת ומגדיר req.id/req.role.
  - פעולות הדאשבורד דורשות תפקיד 'admin' או 'seller' דרך requireRole.
- CORS:
  - הגדרתי origins ספציפיים לפיתוח, כולל Regex לכתובות Expo.
- CSRF:
  - הוספת X-CSRF-Token בכותרות כאשר יש Cookie מתאים; ניתן להקשיח עוד יותר בעסקאות רגישות.
- קלט:
  - לפני שמירה למסד אני מנקה/מוודא טיפוסים (titleSize מספרי, active בוליאני וכו').
- סודות (Secrets):
  - מוגדרים בקובץ env ולא בקוד; cloudinary api_secret וכו'.
- Rate limiting + Brute force:
  - ניתן להוסיף express-rate-limit לראוטים ציבוריים כדי למנוע abuse.

### 24) בדיקות – יחידה, אינטגרציה ו-E2E

- יחידה (Unit):
  - בדיקת publicList: מדמה DB עם שלושה קמפיינים – אחד לא פעיל, אחד בתוקף, אחד מחוץ לתוקף – ומוודא שהפונקציה מחזירה רק את המתאים.
- אינטגרציה (Integration):
  - supertest מול אקספרס – ליצור קמפיין, לעדכן (בלי תמונה), למחוק; לבדוק 200/201 ותגובה סבירה.
- E2E:
  - להריץ שרת, לפתוח את הווב, לאמת שהקרוסלה מציגה את הקמפיין שנוצר הרגע; במובייל – לבדוק דרך Expo Go שהנתונים זהים.
- Mocking Cloudinary:
  - במבחני יצירה עם קובץ – מחליף את uploader באובייקט שמחזיר URL קבוע, כדי לא לתלות באינטרנט.

### 25) DevOps ודיפלוי – docker-compose, סביבות ו-Logs

- docker-compose.yml כולל שלושה שירותים: frontend, backend, mongodb.
- הגדרתי REACT_APP_API_URL=http://api:5001 בצד ה-frontend כאשר רצים בדוקר.
- backend על פורט 5001, עם תלות ב-mongodb.
- Logs:
  - השרת מדפיס לוגים ידידותיים; אפשר להרחיב ל-winston עם רמות שונות וסיבוב קבצים.
- בריאות השירות:
  - /api/health מחזיר uptime, memory, וסביבת ריצה – מעולה ל-k8s readiness/liveness בעתיד.

### 26) ניטור, לוגינג ושקיפות

- פורמט לוגים:
  - ציינתי בקונסולה את חיבורי Socket.io, הודעות שנשלחות, ואירועי שגיאה.
- ניטור שגיאות חיצוני:
  - ניתן לחבר Sentry/Rollbar – אוסיף DSN כמפתח סביבה.
- מדדים (Metrics):
  - אפשר להוסיף /metrics בפורמט Prometheus על בקשות/Latency.

### 27) ביצועים בצד הלקוח – Lighthouse, רשת ותמונות

- דחיסת תמונות בענן (Cloudinary f_auto,q_auto) כדי להקטין משקל.
- lazy-loading לתמונות בהיררכיה נמוכה.
- שימוש ב-React.lazy ו-Suspense לטעינת קוד לפי צורך (Code Splitting).
- מדידת זמן רינדור ו-FID עם Lighthouse.

### 28) נגישות ו-RTL

- תמיכה מלאה בעברית ו-RTL במסכים, כולל כיווניות ב-CSS.
- alt-text לתמונות, aria-label לחיצים בקרוסלה.
- שימוש בניגודיות מספקת לטקסט מעל תמונות; אפשר להוסיף שכבת כהות (overlay) עדינה.

### 29) פתרון תקלות נפוצות – מדריך קצר

- רואה 401 על /api/campaigns/public?
  - ודא שב-campaignRoutes.js הנתיב public רשום לפני /:id.
- רואה net::ERR_NAME_NOT_RESOLVED על תמונת placeholder?
  - עבור ל-dummyimage.com או השתמש בקובץ סטטי מה-CDN שלך.
- האפליקציה במובייל לא מושכת נתונים?
  - ודא ש-API_BASE_URL מצביע על אותו שרת כמו האתר, ושה-Expo במצב Tunnel או LAN תקין.
- קישורי CTA לא עובדים במובייל?
  - בדוק parseAction – ייתכן והלינק לא במבנה צפוי; הוסף case חדש או ברירת מחדל.

### 30) מפת דרכים (Roadmap)

- מיון Drag & Drop לקמפיינים בדאשבורד (עדכון order).
- תצוגה מקדימה לקמפיין מהדאשבורד (כפתור Preview שמוסיף query לדף הבית).
- קאשינג לקמפיינים ציבוריים (TTL 60 שניות) לשיפור זמני תגובה.
- בדיקות אוטומטיות CI, ודשבורד ניטור שגיאות פרודקשן.
- תיוג A/B בקמפיינים (גרסאות A/B) לשיפור המרות.
